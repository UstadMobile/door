package com.ustadmobile.door.paging

import app.cash.paging.PagingSource
import app.cash.paging.PagingSourceLoadParams
import app.cash.paging.PagingSourceLoadResult
import app.cash.paging.PagingState
import com.ustadmobile.door.DoorDatabaseRepository
import com.ustadmobile.door.log.DoorLogLevel
import io.github.aakira.napier.Napier
import kotlinx.atomicfu.atomic

/**
 * Provides a PagingSource that works with the replication system. This is to be used with DoorOffsetLimitRemoteMediator.
 * See DoorOffsetLimitRemoteMediator docs for a discussion of why the normal RemoteMediator concept is flawed and
 * doesn't really work in many cases.
 *
 * @param repo The DoorDatabaseRepository being used
 * @param repoPath the endpoint path (used for logging)
 * @param dbPagingSource the PagingSource from the underlying database
 * @param onLoadHttp a function (generated by the DoorRepositoryProcessor) that runs the http request and inserts any
 *        new replicated entities into the database. It should return a Boolean indicating if the end of pagination
 *        has been reached.
 */
class DoorRepositoryReplicatePullPagingSource<Value: Any>(
    internal val repo: DoorDatabaseRepository,
    private val repoPath: String,
    private val dbPagingSource: PagingSource<Int, Value>,
    private val onLoadHttp: suspend (params: PagingSourceLoadParams<Int>) -> Boolean,
) : DoorRepositoryPagingSource<Int, Value>(), PagingSourceWithHttpLoader<Int> {

    private val dbInvalidateCallbackRegistered = atomic(false)

    private val invalidated = atomic(false)

    private var lastLoadParams: PagingSourceLoadParams<Int>? = null

    private val onDbInvalidatedCallback: () -> Unit = {
        onDbInvalidated()
    }

    private fun onDbInvalidated() {
        Napier.v("DoorRepositoryReplicatePullPagingSource: onDbInvalidated")
        dbPagingSource.unregisterInvalidatedCallback(onDbInvalidatedCallback)
        if(!invalidated.getAndSet(true)) {
            Napier.v("DoorRepositoryReplicatePullPagingSource: call invalidate")
            invalidate()
        }

    }

    override fun getRefreshKey(state: PagingState<Int, Value>): Int? {
        return dbPagingSource.getRefreshKey(state).also {
            repo.config.logger.log(DoorLogLevel.VERBOSE, "DoorRepositoryReplicatePullPagingSource: getRefreshKey: $it")
        }
    }

    override suspend fun load(
        params: PagingSourceLoadParams<Int>
    ): PagingSourceLoadResult<Int, Value> {
        Napier.v("DoorRepositoryReplicatePullPagingSource: load key=${params.key}")
        lastLoadParams = params
        if(!dbInvalidateCallbackRegistered.getAndSet(true)) {
            Napier.v("DoorRepositoryReplicatePullPagingSource: register db invalidate callback")
            dbPagingSource.registerInvalidatedCallback(onDbInvalidatedCallback)
        }

        return dbPagingSource.load(params)
    }

    /**
     * This simply triggers the onLoadHttp function (e.g. the generated function). It is invoked by
     * DoorOffsetLimitRemoteMediator
     */
    override suspend fun loadHttp(
        params: PagingSourceLoadParams<Int>
    ): Boolean {
        return onLoadHttp(params)
    }

    companion object {

        const val PARAM_BATCHSIZE = "pagingBatchSize"

        const val PARAM_KEY = "pagingKey"

        const val PARAM_LOAD_PARAM_TYPE = "pagingLoadParamType"

    }
}